# -*- coding: utf-8 -*-
"""----------------------------------------------------------------------------
    KpMatch.py
        Created on Tue Jul 12 22:36:03 2016
        @author: h1sat0r1
----------------------------------------------------------------------------"""


# -*- coding: utf-8 -*-
"""
Keypoint_Matching.ipynb
Automatically generated by Colaboratory.
Original file is located at https://colab.research.google.com/drive/1EyL4dwViaMSy2t8-Qli-z-U28nN7ErTc
"""

import os
import numpy as np
import glob
import cv2 as cv
import sys
import matplotlib.pyplot as plt


## DIRECTORY
DIR_OUTPUT_NAME = 'output'
DIR_MAIN        = os.getcwd()
DIR_OUTPUT      = os.path.join(DIR_MAIN, DIR_OUTPUT_NAME)

## DEFAULT CONST NUMBERS
PARAMS_DRAW        = dict(matchColor=(0,255,255), singlePointColor=(255,0,0), flags=0)
NUM_HIST_ANGLE     = 360  ## DO NOT CHANGE THIS
NUM_HIST_OCTAVE    = 8

## DEFAULT THRESHOLDS
THRESH_NN_DIST_RATIO   = 0.70
THRESH_RANSAC          = 0.70
THRESH_MIN_MATCH_COUNT = 8
THRESH_HIST_ANGLE      = 15
THRESH_HIST_OCTAVE     = 1

## KEYPOINT DETECTOR
DETECTOR_SIFT  = 'SIFT'
DETECTOR_SURF  = 'SURF'
DETECTOR_ORB   = 'ORB'
DETECTOR_AGAST = 'AGAST'
DETECTOR_AKAZE = 'AKAZE'
DETECTOR_HARRIS_LAPLACE = 'HARRIS_LAPLACE'
DETECTOR = DETECTOR_AKAZE  ## DEFAULT 

## KEYPOINT DESCRIPTOR
DESCRIPTOR_SIFT  = 'SIFT'
DESCRIPTOR_SURF  = 'SURF'
DESCRIPTOR_DAISY = 'DAISY'
DESCRIPTOR_ORB   = 'ORB'
DESCRIPTOR_BRISK = 'BRISK'
DESCRIPTOR_FREAK = 'FREAK'
DESCRIPTOR_AKAZE = 'AKAZE'
DESCRIPTOR = DESCRIPTOR_AKAZE  ## DEFAULT


"""============================================================================
    dCreate()
============================================================================"""
def dCreate(_detType, _desType):
    
    #print('Detector:' + _detType, end=',  ')
    #print('Descriptor:' + _desType)
    
    ## Keypoint Detector ##
    if   _detType == 'SIFT':
        detect_ = cv.xfeatures2d.SIFT_create()

    elif _detType == 'SURF':
        detect_ = cv.xfeatures2d.SURF_create()

    elif _detType == 'ORB':
        detect_ = cv.ORB_create()

    elif _detType == 'AGAST':
        detect_ = cv.AgastFeatureDetector_create()

    elif _detType == 'AKAZE':
        detect_ = cv.AKAZE_create()

    elif _detType == 'HARRIS_LAPLACE':
    	detect_ = cv.xfeatures2d.HarrisLaplaceFeatureDetector_create()

    else:
        detect_ = cv.ORB_create()
        print('No keypoint detection method is specified.')
        print('Use ORB detector.')


    ## Keypoint Descriptor ##
    if   _desType == 'SIFT':
        descript_ = cv.xfeatures2d.SIFT_create()

    elif _desType == 'SURF':
        descript_ = cv.xfeatures2d.SURF_create()
        
    elif _desType == 'DAISY':
        descript_ = cv.xfeatures2d.DAISY_create()

    elif _desType == 'ORB':
        descript_ = cv.ORB_create()

    elif _desType == 'BRISK':
        descript_ = cv.BRISK_create()

    elif _desType == 'FREAK':
        descript_ = cv.xfeatures2d.FREAK_create()

    elif _desType == 'AKAZE':
        descript_ = cv.AKAZE_create()    

    else:
        descript_ = cv.ORB_create()
        print('No keypoint description method is specified.')
        print('Use ORB descriptor.')
    
    return [detect_, descript_]



"""============================================================================
    createHist()
============================================================================"""
def createHist(_kp0, _kp1, _matches, _num_hist_angle, _num_hist_octave):

    """
    Creating histograms of dif of angle and octave
    """

    ## Create lists ##
    hist_angle  = [0] * _num_hist_angle
    hist_octave = [0] * (_num_hist_octave * 2 + 1)
    
    
    ## Roop for all matches ##
    for m in _matches:

        ## Angle ##
        gap_angle = int(_kp1[m.trainIdx].angle - _kp0[m.queryIdx].angle)
        while (gap_angle < 0):
            gap_angle += NUM_HIST_ANGLE

        hist_angle[gap_angle] += 1


        ## Octave ##        
        gap_octave = ((_kp1[m.trainIdx].octave&0xFF) - (_kp0[m.queryIdx].octave&0xFF))
        if ((gap_octave < -_num_hist_octave) or (_num_hist_octave < gap_octave)):
            continue

        hist_octave[gap_octave + _num_hist_octave] += 1


    return [hist_angle, hist_octave]



"""============================================================================
    calcDiffHistAngle()
============================================================================"""
def calcDiffHistAngle(_id0, _id1, _num_hist_angle):

    """
    Calcurating the gap of two bins in angle histogram
    """

    ## Simple gap ##
    dif = _id1 - _id0


    ## Clip in range[0-359] ##
    while(not(0 <= dif < _num_hist_angle)):
        
        if (dif < 0):
            dif += _num_hist_angle
            
        elif(NUM_HIST_ANGLE <= dif):
            dif -= _num_hist_angle

       
    return dif



"""============================================================================
    pickGoodMatches()
============================================================================"""
def pickGoodMatches(_kp0, _kp1, _matches, 
                    _detType, _desType, 
                    _thresh_NN_dist_ratio, 
                    _thresh_hist_angle, 
                    _thresh_hist_octave, 
                    _thresh_min_match_count, 
                    _thresh_RANSAC, 
                    _num_hist_angle, 
                    _num_hist_octave, 
                    _do_plot
                    ):
    
    """
    Picking better matches
    """
    
    ## Thresholded by distance ##
    g  = []

    ## Thresholded by distance, angle and octave ##
    g_ = []

    ## Thresholding based on distance ##    
    for m1,n1 in _matches:
        f_dist   = (m1.distance < _thresh_NN_dist_ratio * n1.distance)
        if (f_dist):
            g.append(m1)

    ## Creating histograms ##
    hist_angle, hist_octave = createHist(_kp0, _kp1, g, _num_hist_angle=_num_hist_angle, _num_hist_octave=_num_hist_octave)

    ## Plot the histograms##
    if _do_plot is True:
        ## Angle Hist Preview ##
        plt.figure(100, figsize=(12, 6))
        plt.title("Angle dif histogram")
        plt.xticks( np.arange(0, 360, 15) )
        #plt.hist(hist_angle, bins=_num_hist_angle, range=(0,360))
        plt.plot(hist_angle)
        #plt.show()

        ## Octve Hist Preview ##
        plt.figure(101, figsize=(12, 6))
        plt.title("Octave dif histogram")
        plt.xticks( np.arange(0, 2*_num_hist_octave+1, 1) )
        #plt.hist(hist_octave, bins=_num_hist_octave*2+1, range=(-_num_hist_octave,_num_hist_octave))
        plt.plot(hist_octave)
        #plt.show()    
        plt.pause(.0001)

    
    ## Get max and its index ##
    num_max_hist_angle  = max(hist_angle)
    num_max_hist_octave = max(hist_octave)
    id_max_hist_angle   = hist_angle.index(num_max_hist_angle) 
    id_max_hist_octave  = hist_octave.index(num_max_hist_octave) 
    

    ## Thresholding based on angle and octave ##    
    for m2 in g:

        ## Angle bin number ##
        dif_angle  = int(_kp1[m2.trainIdx].angle - _kp0[m2.queryIdx].angle + 0.5)

        ## Octave bin number ##
        dif_octave = (_kp1[m2.trainIdx].octave&0xFF) - (_kp0[m2.queryIdx].octave&0xFF)
        dif_octave += (_num_hist_octave + 1)

        ## Calcurate the gap from max bin ##
        dif_hist_angle  = calcDiffHistAngle(id_max_hist_angle, dif_angle, _num_hist_angle)
        dif_hist_octave = abs(id_max_hist_octave - dif_octave)
        
        ## Flags ##
        f_angle  = (dif_hist_angle  <= _thresh_hist_angle)
        f_octave = (dif_hist_octave <= _thresh_hist_octave)

        ## Add for g_ ##
        if (f_angle and f_octave):
            g_.append(m2)

    return g_


"""============================================================================
    Keypoint Match ()
============================================================================"""
def kpMatch(_img_master, _img_slave,
            _detType=DETECTOR,
            _desType=DESCRIPTOR,
            _thresh_NN_dist_ratio=THRESH_NN_DIST_RATIO,
            _thresh_hist_angle=THRESH_HIST_ANGLE,
            _thresh_hist_octave=THRESH_HIST_OCTAVE,
            _thresh_min_match_count=THRESH_MIN_MATCH_COUNT,
            _thresh_RANSAC=THRESH_RANSAC,
            _num_hist_angle=NUM_HIST_ANGLE,
            _num_hist_octave=NUM_HIST_OCTAVE,
            _dir_output=None,
            _do_plot=False
            ):

    """
    Input:
        _img_master,  ## Mandatory
        _img_slave,   ## Mandatory
        _detType=DETECTOR,
        _desType=DESCRIPTOR,
        _thresh_NN_dist_ratio=THRESH_NN_DIST_RATIO,
        _thresh_hist_angle=THRESH_HIST_ANGLE,
        _thresh_hist_octave=THRESH_HIST_OCTAVE,
        _thresh_min_match_count=THRESH_MIN_MATCH_COUNT,
        _thresh_RANSAC=THRESH_RANSAC,
        _num_hist_angle=NUM_HIST_ANGLE,
        _num_hist_octave=NUM_HIST_OCTAVE,
        _dir_output=None,
        _do_plot=False
    Output:
        proj2,  ## Projection Mat: Slave -> Master
        kp0,    ## Keypoints (Master)
        kp1,    ## Keypoints (Slave)
        mask,   ## Mask (?)
        img2,   ## Image of Matching Result
        kpimg0, ## Image of Keypoint Detection (Master)
        kpimg1  ## Image of Keypoint Detection (Slave)
    """

    ## Glayscale ##
    if len(_img_master.shape) == 2:
        gry0 = _img_master
        img0 = cv.cvtColor(gry0, cv.COLOR_GRAY2BGR)
    else:
        gry0 = cv.cvtColor(_img_master, cv.COLOR_BGR2GRAY)
        img0 = _img_master

    if len(_img_slave.shape) == 2:
        gry1 = _img_slave
        img1 = cv.cvtColor(gry1, cv.COLOR_GRAY2BGR)
    else:
        gry1 = cv.cvtColor(_img_slave, cv.COLOR_BGR2GRAY)
        img1 = _img_slave
    
    
    ## Detector and Descriptor##
    detect, descript = dCreate(_detType, _desType)
    
    
    ## Detection ##
    kp0 = detect.detect(gry0)
    kp1 = detect.detect(gry1)
    
    
    ## Description ##
    kp0, dsc0 = descript.compute(gry0, kp0)
    kp1, dsc1 = descript.compute(gry1, kp1)
    
    ## Matching ##
    try:
        bf = cv.BFMatcher()
        matches = bf.knnMatch(dsc0, dsc1, k=2)
        good = pickGoodMatches(kp0, kp1, matches, \
                                _detType=_desType, _desType=_desType, \
                                _thresh_NN_dist_ratio=_thresh_NN_dist_ratio, \
                                _thresh_hist_angle=_thresh_hist_angle, \
                                _thresh_hist_octave=_thresh_hist_octave, \
                                _thresh_min_match_count=_thresh_min_match_count, \
                                _thresh_RANSAC=_thresh_RANSAC, \
                                _num_hist_angle=_num_hist_angle, \
                                _num_hist_octave=_num_hist_octave, \
                                _do_plot=False)
        
        ## Compute Homography ##
        srcPts = np.float32([kp0[m.queryIdx].pt for m in good]).reshape(-1,1,2)
        dstPts = np.float32([kp1[m.trainIdx].pt for m in good]).reshape(-1,1,2)


        if(len(good) < _thresh_min_match_count):

            ## In case of few matches ##
            print("Not enough matches are found. Skip calclating homography.\n")
            proj2 = None
            mask  = None

        else:
            ## Enough number of matches ##
            ## Calculating homography ##
            proj2, mask = cv.findHomography(dstPts, srcPts, cv.RANSAC, _thresh_RANSAC)
            
    except:
        print("-Not enough matches are found. Skip calclating homography.\n")
        srcPts = None
        dstPts = None
        proj2 = None
        mask  = None
        good = []

    ## Draw Matching Result ##
    img2 = cv.drawMatchesKnn(img0, kp0, img1, kp1, [good], None, **PARAMS_DRAW)
    
    
    ## Draw Detection&Description Results ##
    kpimg0 = cv.drawKeypoints(img0, kp0, None, flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    kpimg1 = cv.drawKeypoints(img1, kp1, None, flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    
    ## Return
    return [proj2, srcPts, dstPts, mask, img2, kpimg0, kpimg1]


 
"""============================================================================
    Keypoint Match ver.2
============================================================================"""
def kpMatch2(_img_master, _img_slave, _detector, _descriptor,
            _thresh_NN_dist_ratio=THRESH_NN_DIST_RATIO,
            _thresh_hist_angle=THRESH_HIST_ANGLE,
            _thresh_hist_octave=THRESH_HIST_OCTAVE,
            _thresh_min_match_count=THRESH_MIN_MATCH_COUNT,
            _thresh_RANSAC=THRESH_RANSAC,
            _num_hist_angle=NUM_HIST_ANGLE,
            _num_hist_octave=NUM_HIST_OCTAVE,
            _dir_output=None,
            _do_plot=False
            ):

    """
    DIFFERENCE FROM KPMATCH(): YOU NEED TO GIVE DETECTOR AND DESCRIPTOR AS ARGUMENTS.

    Input:
        _img_master,  ## Mandatory
        _img_slave,   ## Mandatory
        _detector=dCreate(DETECTOR_AKAZE),
        _descriptorType=dCreate(DESCRIPTOR_AKAZE),
        _thresh_NN_dist_ratio=THRESH_NN_DIST_RATIO,
        _thresh_hist_angle=THRESH_HIST_ANGLE,
        _thresh_hist_octave=THRESH_HIST_OCTAVE,
        _thresh_min_match_count=THRESH_MIN_MATCH_COUNT,
        _thresh_RANSAC=THRESH_RANSAC,
        _num_hist_angle=NUM_HIST_ANGLE,
        _num_hist_octave=NUM_HIST_OCTAVE,
        _dir_output=None,
        _do_plot=False
    Output:
        proj2,  ## Projection Mat: Slave -> Master
        kp0,    ## Keypoints (Master)
        kp1,    ## Keypoints (Slave)
        mask,   ## Mask (?)
        img2,   ## Image of Matching Result
        kpimg0, ## Image of Keypoint Detection (Master)
        kpimg1  ## Image of Keypoint Detection (Slave)
    """

    ## Glayscale
    if len(_img_master.shape) == 2:
        gry0 = _img_master
        img0 = cv.cvtColor(gry0, cv.COLOR_GRAY2BGR)
    else:
        gry0 = cv.cvtColor(_img_master, cv.COLOR_BGR2GRAY)
        img0 = _img_master

    if len(_img_slave.shape) == 2:
        gry1 = _img_slave
        img1 = cv.cvtColor(gry1, cv.COLOR_GRAY2BGR)
    else:
        gry1 = cv.cvtColor(_img_slave, cv.COLOR_BGR2GRAY)
        img1 = _img_slave
    
    
    ## Detection
    kp0 = _detector.detect(gry0)
    kp1 = _detector.detect(gry1)
        
        
    ## Description
    kp0, dsc0 = _descriptor.compute(gry0, kp0)
    kp1, dsc1 = _descriptor.compute(gry1, kp1)
    
    ## Matching
    try:
        bf = cv.BFMatcher()
        matches = bf.knnMatch(dsc0, dsc1, k=2)
        good = pickGoodMatches(kp0, kp1, matches, \
                                _detType=_desType, _desType=_desType, \
                                _thresh_NN_dist_ratio=_thresh_NN_dist_ratio, \
                                _thresh_hist_angle=_thresh_hist_angle, \
                                _thresh_hist_octave=_thresh_hist_octave, \
                                _thresh_min_match_count=_thresh_min_match_count, \
                                _thresh_RANSAC=_thresh_RANSAC, \
                                _num_hist_angle=_num_hist_angle, \
                                _num_hist_octave=_num_hist_octave, \
                                _do_plot=False)
        
        ## Compute Homography ##
        srcPts = np.float32([kp0[m.queryIdx].pt for m in good]).reshape(-1,1,2)
        dstPts = np.float32([kp1[m.trainIdx].pt for m in good]).reshape(-1,1,2)


        if(len(good) < _thresh_min_match_count):

            ## In case of few matches ##
            print("Not enough matches are found. Skip calclating homography.\n")
            proj2 = None
            mask  = None

        else:
            ## Enough number of matches ##
            ## Calculating homography ##
            proj2, mask = cv.findHomography(dstPts, srcPts, cv.RANSAC, _thresh_RANSAC)
            
    except:
        print("-Not enough matches are found. Skip calclating homography.\n")
        srcPts = None
        dstPts = None
        proj2 = None
        mask  = None
        good = []

    ## Draw Matching Result
    img2 = cv.drawMatchesKnn(img0, kp0, img1, kp1, [good], None, **PARAMS_DRAW)
    
    
    ## Draw Detection&Description Results ##
    kpimg0 = cv.drawKeypoints(img0, kp0, None, flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    kpimg1 = cv.drawKeypoints(img1, kp1, None, flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)
    
    ## Return
    return [proj2, srcPts, dstPts, mask, img2, kpimg0, kpimg1]
    


"""============================================================================
============================================================================"""
if __name__ == "__main__":
    
    ## CHECK OPENCV VERSION
    print('OpenCV {0}'.format(cv.__version__))


    ## Input Files
    FILENAME_IMAGE_0   = "./input/boat/img1.pgm"
    FILENAME_IMAGE_1   = "./input/boat/img4.pgm"
    
    
    ## IMREAD
    img0 = cv.imread(FILENAME_IMAGE_0, cv2.IMREAD_COLOR)
    img1 = cv.imread(FILENAME_IMAGE_1, cv2.IMREAD_COLOR)

    
    ## OUTPUT DIRECTORY
    DIRNAME_OUTPUT = "./output"
    DIR_OUTPUT     = DIRNAME_OUTPUT + "/"

    
    ## CREATE OUTPUT DIRECTORY
    try:
        os.mkdir(DIRNAME_OUTPUT)
        print('Created Output dir \"' + DIRNAME_OUTPUT + '\".')
        
    except FileExistsError as e:
        #print(e.strerror)
        #print(e.errno)
        #print(e.filename)
        print('Output dir \"'+ e.filename + '\" already exists.')


    ## MATCHING
    proj, srcPts, dstPts, mask, img, kpimg0, kpimg1 = kpMatch(img0, img1)
    wrp = cv.warpPerspective(img0, proj, (img1.shape[1],img1.shape[0]))


    ## PRINT HOMOGRAPHY MAT
    print('Homography mat (img0->img1)')
    print(proj)    
    

    ## SAVE
    sys.stdout = open(DIR_OUTPUT + 'homography.txt', 'w')
    print(proj, file=sys.stdout) 
    

    ## MERGE
    alpha = 0.5
    beta  = 0.5
    mrg  = cv.addWeighted(img1, alpha, wrp, beta, 0)
    

    ## SHOW AND WRITE
    cv.imshow("warp", wrp)
    cv.imshow("merge", mrg)
    cv.imshow("image", img)
    cv.imwrite(DIR_OUTPUT + "_Warp.jpg", wrp)
    cv.imwrite(DIR_OUTPUT + "_Merge.jpg", mrg)
    cv.waitKey()
    cv.destroyAllWindows()

#EOF